## 滑动窗口

![sliding-window](https://pic.leetcode-cn.com/af4821c41d5b093e6a41ad5602208f9e7057cc1b002cd0053de71bc9a0e35b12.jpg)

滑动窗口的重要性质是：

窗口的左边界和右边界永远只能向右移动，而不能向左移动。这是为了保证滑动窗口的时间复杂度是 O(n)。如果左右边界向左移动的话，这叫做“回溯”

我们关注的是滑动窗口中所有数的和。

当滑动窗口的右边界向右移动时，也就是 j = j + 1，窗口中多了一个数字 j，窗口的和也就要加上 j。当滑动窗口的左边界向右移动时，也就是 i = i + 1，窗口中少了一个数字 i，窗口的和也就要减去 i。滑动窗口只有 右边界向右移动（扩大窗口） 和 左边界向右移动（缩小窗口） 两个操作。

可能会有小伙伴问到，为什么j <= target//2 + 1？其实这是很直观的一个事情，直接举例子归纳就行

你看：9 = 5 + x，x是不可能比5大的
再看：15 = 8 + x，x是不可能比8大的
所以这就考验总结出一个规律：**即一个大于1的正整数，总是小于，它的中值加上一个比中值大的数。**

所以，当右边界跨过中值的那一刻，窗口内的和就永远也无法触及到target了。

### 

```java

class Solution {

  public int[][] findContinuousSequence(int target) {

  int i = 1; // 滑动窗口的左边界

  int j = 1; // 滑动窗口的右边界

  int sum = 0; // 滑动窗口中数字的和

  List<int[]> res = new ArrayList<>();



  while (i <= target / 2) {

​    if (sum < target) {

​      // 右边界向右移动

​      sum += j;

​      j++;

​    } else if (sum > target) {

​      // 左边界向右移动

​      sum -= i;

​      i++;

​    } else {

​      // 记录结果

​      int[] arr = new int[j-i];

​      for (int k = i; k < j; k++) {

​        arr[k-i] = k;

​      }

​      res.add(arr);

​      // 右边界向右移动

​      sum -= i;

​      i++;

​    }

  }



  return res.toArray(new int[res.size()][]);

}

}
```

1.[面试题57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

2.[面试题59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)
