#### [剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

> - 最小的K个用最大堆，最大的K个用最小堆。
> - 我们先用前K个数建立了一个堆，然后遍历数组来维护这个堆。这种做法带来了三个好处：（1）不会改变数据的输入顺序（按顺序读的）；（2）不会占用太多的内存空间（事实上，一次只读入一个数，内存只要求能容纳前K个数即可）；（3）由于（2），决定了它特别适合处理海量数据。
> - 执行用时：5 ms, 在所有 Java 提交中击败了73.62%的用户

```java
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        int len = arr.length;
        if(len == 0 || k == 0){
            return new int[0];
        }
        int[] ans = topK(arr, k);
        return ans;
    }
    private int[] topK(int[] arr, int k){
        int[] top = new int[k];
        for(int i = 0; i < k; i++){
            top[i] = arr[i];
        }
        buildHeap(top, k);
        for(int i = k; i < arr.length; i++){
            int temp = top[0];
            if(arr[i] < temp){
                setTop(top, arr[i]);
            }
        }
        return top;
    }
    private void setTop(int[] arr, int top){
        arr[0] = top;
        heapify(arr, arr.length, 0);
    }
    private void buildHeap(int[] arr, int len){
        for(int i = len / 2 - 1; i >= 0; i--){
            heapify(arr, len, i);
        }
    }
    private void heapify(int[] arr, int len, int i){
        int largest = i;
        int l = i * 2 + 1;
        int r = i * 2 + 2;
        if(l < len && arr[l] > arr[largest]){
            largest = l;
        }
        if(r < len && arr[r] > arr[largest]){
            largest = r;
        }
        if(largest != i){
            int temp = arr[largest];
            arr[largest] = arr[i];
            arr[i] = temp;
            heapify(arr, len, largest);
        }
    }
}
```



> 快排复习

```java
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        if(arr.length == 0){
            return new int[]{};
        }
        quickSort(arr,0,arr.length-1);
        int[] res = new int[k];
        System.arraycopy(arr,0,res,0,k);
        return res;
    }

    private void quickSort(int[] arr, int left, int right){
        if(left < right){
            int pivot = sort(arr,left,right);
            quickSort(arr,left,pivot-1);
            quickSort(arr,pivot+1,right);
        }
    }

    private int sort(int[] arr, int left, int right){
        int pivotValue = arr[left];
        while(left < right){
            while(left < right && arr[right] >= pivotValue){
                right--;
            }
            arr[left] = arr[right];
            while(left < right && arr[left] <= pivotValue){
                left++;
            }
            arr[right] = arr[left];
        }
        arr[left] = pivotValue;
        return left;
    }
}
```

> 调用库函数

```java
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        if(arr.length == 0){
            return new int[]{};
        }
        Arrays.sort(arr);
        int[] res = new int[k];
        // System.arraycopy(arr,0,newarray,0,k);
        for(int i = 0; i < k; i++){
            res[i] = arr[i];
        }
        return res;
    }
}
```
