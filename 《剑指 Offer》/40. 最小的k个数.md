#### [剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

> - 最小的K个用最大堆，最大的K个用最小堆。
>
> - 我们先用前K个数建立了一个堆，然后遍历数组来维护这个堆。这种做法带来了三个好处：（1）不会改变数据的输入顺序（按顺序读的）
>
>   （2）不会占用太多的内存空间（事实上，一次只读入一个数，内存只要求能容纳前K个数即可）
>
>   （3）由于（2），决定了它特别适合处理海量数据
>
> - 执行用时：1 ms, 在所有 Java 提交中击败了98.86%的用户

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        return topK(nums, k);
    }
    private int topK(int[] nums, int k){
        int[] top = new int[k];
        for(int i = 0; i < k; i++){
            top[i] = nums[i];
        }
        buildHeap(top, k);
        for(int i = k; i < nums.length; i++){
            if(nums[i] > top[0]){
                top[0] = nums[i];
                heapify(top, k, 0);
            }
        }
        return top[0];
    }
    private void buildHeap(int[] nums, int len){
        for(int i = len / 2 - 1; i >= 0; i--){
            heapify(nums, len, i);
        }
    }
    private void heapify(int[] nums, int len, int i){
        int smallest = i;
        int l = i * 2 + 1;
        int r = i * 2 + 2;
        if(l < len && nums[l] < nums[smallest]){
            smallest = l;
        }
        if(r < len && nums[r] < nums[smallest]){
            smallest = r;
        }
        if(i != smallest){
            int temp = nums[i];
            nums[i] = nums[smallest];
            nums[smallest] = temp;
            heapify(nums, len, smallest);
        }
    }
}
```

> **牛客**
>
> - 注意`k > length`，特判

```java
public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        if(input.length == 0 || k == 0 || k > input.length){
            return new ArrayList<>();
        }
        return topK(input, k);
    }
    private ArrayList<Integer> topK(int[] input, int k){
        int[] top = new int[k];
        for(int i = 0; i < k; i++){
            top[i] = input[i];
        }
        buildHeap(top, k);
        for(int i = k; i < input.length; i++){
            int temp = top[0];
            if(temp > input[i]){
                setTop(top, input[i]);
            }
        }
        ArrayList<Integer> list = new ArrayList<>();
        for(int num : top){
            list.add(num);
        }
        return list;
    }
    private void buildHeap(int[] top, int len){
        for(int i = len / 2 - 1; i >= 0; i--){
            heapify(top, len, i);
        }
    }
    private void heapify(int[] top, int len, int i){
        int largest = i;
        int l = i * 2 + 1;
        int r = i * 2 + 2;
        if(l < len && top[l] > top[largest]){
            largest = l;
        }
        if(r < len && top[r] > top[largest]){
            largest = r;
        }
        if(largest != i){
            int temp = top[largest];
            top[largest] = top[i];
            top[i] = temp;
            heapify(top, len, largest);
        }
    }
    private void setTop(int[] top, int temp){
        top[0] = temp;
        heapify(top, top.length, 0);
    }
}
```

